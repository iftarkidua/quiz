<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sliding Puzzle</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #f0f2f5;
            font-family: Arial, sans-serif;
            touch-action: manipulation;
        }

        .game-container {
            width: 100%;
            max-width: 800px;
            position: relative;
        }

        .puzzle-container {
            position: relative;
            width: 100%;
            padding-top: 75%; /* 3:4 aspect ratio */
            margin: 0 auto;
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .tile {
            position: absolute;
            background-size: 400% 300%;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            cursor: pointer;
            user-select: none;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-sizing: border-box;
        }

        .tile:hover {
            transform: scale(1.02);
            z-index: 2;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .empty {
            background: #f8f9fa;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.05);
        }

        @media (max-width: 600px) {
            .puzzle-container {
                border-radius: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="puzzle-container" id="puzzleContainer"></div>
    </div>

    <script>
        const ROWS = 3;
        const COLS = 4;
        const PUZZLE_IMAGE = 'https://rukminim2.flixcart.com/image/850/1000/xif0q/poster/t/i/y/small-disha-patani-14-disha-patani-poster-multicolor-photo-paper-original-imaghpycyw4rqwf5.jpeg?q=90&crop=false';
        
        let tileSize = { width: 0, height: 0 };
        let emptyPos = { row: ROWS - 1, col: COLS - 1 };
        let tiles = [];

        function initializePuzzle() {
            const container = document.getElementById('puzzleContainer');
            container.innerHTML = '';
            
            // Calculate tile dimensions based on container size
            const containerWidth = container.offsetWidth;
            tileSize = {
                width: containerWidth / COLS,
                height: (containerWidth * 0.75) / ROWS
            };

            // Create tiles
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    if (row === emptyPos.row && col === emptyPos.col) continue;
                    
                    const tile = document.createElement('div');
                    tile.className = 'tile';
                    tile.style.backgroundImage = `url(${PUZZLE_IMAGE})`;
                    tile.style.backgroundPosition = `${(col * 100) / (COLS - 1)}% ${(row * 100) / (ROWS - 1)}%`;
                    tile.dataset.row = row;
                    tile.dataset.col = col;
                    tile.addEventListener('click', handleTileClick);
                    tile.addEventListener('touchstart', handleTileClick);
                    
                    tiles.push(tile);
                    container.appendChild(tile);
                }
            }

            // Create empty space
            const emptyTile = document.createElement('div');
            emptyTile.className = 'tile empty';
            container.appendChild(emptyTile);
            
            shufflePuzzle();
            updatePositions();
        }

        function shufflePuzzle() {
            // Perform random valid moves to shuffle
            const shuffleMoves = 100;
            for (let i = 0; i < shuffleMoves; i++) {
                const validMoves = getValidMoves();
                const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                swapTiles(randomMove.row, randomMove.col);
            }
        }

        function getValidMoves() {
            const moves = [];
            const directions = [
                { row: -1, col: 0 }, // up
                { row: 1, col: 0 },  // down
                { row: 0, col: -1 }, // left
                { row: 0, col: 1 }   // right
            ];

            directions.forEach(dir => {
                const newRow = emptyPos.row + dir.row;
                const newCol = emptyPos.col + dir.col;
                if (newRow >= 0 && newRow < ROWS && newCol >= 0 && newCol < COLS) {
                    moves.push({ row: newRow, col: newCol });
                }
            });
            return moves;
        }

        function handleTileClick(e) {
            e.preventDefault();
            const tile = e.target;
            const row = parseInt(tile.dataset.row);
            const col = parseInt(tile.dataset.col);
            
            if (isAdjacent(row, col)) {
                swapTiles(row, col);
                updatePositions();
                if (checkSolution()) {
                    setTimeout(() => alert('Congratulations! Puzzle solved!'), 300);
                }
            }
        }

        function isAdjacent(row, col) {
            return (Math.abs(row - emptyPos.row) + Math.abs(col - emptyPos.col)) === 1;
        }

        function swapTiles(row, col) {
            // Find the clicked tile
            const clickedTile = tiles.find(t => 
                parseInt(t.dataset.row) === row && 
                parseInt(t.dataset.col) === col
            );

            // Update empty position
            clickedTile.dataset.row = emptyPos.row;
            clickedTile.dataset.col = emptyPos.col;
            emptyPos = { row, col };
        }

        function updatePositions() {
            tiles.forEach(tile => {
                const col = parseInt(tile.dataset.col);
                const row = parseInt(tile.dataset.row);
                
                tile.style.width = `${tileSize.width}px`;
                tile.style.height = `${tileSize.height}px`;
                tile.style.left = `${col * tileSize.width}px`;
                tile.style.top = `${row * tileSize.height}px`;
            });

            // Update empty tile position
            const emptyTile = document.querySelector('.empty');
            emptyTile.style.width = `${tileSize.width}px`;
            emptyTile.style.height = `${tileSize.height}px`;
            emptyTile.style.left = `${emptyPos.col * tileSize.width}px`;
            emptyTile.style.top = `${emptyPos.row * tileSize.height}px`;
        }

        function checkSolution() {
            return tiles.every(tile => {
                const originalRow = parseInt(tile.style.backgroundPositionY?.match(/\d+/)?.[0] || 0;
                const originalCol = parseInt(tile.style.backgroundPositionX?.match(/\d+/)?.[0] || 0;
                return (
                    parseInt(tile.dataset.row) === originalRow &&
                    parseInt(tile.dataset.col) === originalCol
                );
            });
        }

        // Initialize and handle resize
        window.addEventListener('load', initializePuzzle);
        window.addEventListener('resize', () => {
            tileSize = {
                width: puzzleContainer.offsetWidth / COLS,
                height: (puzzleContainer.offsetWidth * 0.75) / ROWS
            };
            updatePositions();
        });
    </script>
</body>
</html>
